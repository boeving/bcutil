报头结构
========

0                              15                              31
+-------------------------------+-------------------------------+
|          Data ID #SND         |          Data ID #RCV         |  // 数据体ID
+-------------------------------+-------------------------------+
|                        Sequence number                        |  // 序列号（SN）
+---------------------------------------------------------------+
|                      Acknowledgment number                    |  // 确认号（SN+1）
+-------------------------------+-------------------------------+
| RPZ-  |  ...  | . |R|S|B|R|B|E|              |                |  // 重组扩展
| Extra |  ...  | . |E|E|Y|T|E|N| ACK distance |  Send distance |  // 标记区
| Size  |  (4)  | . |Q|S|E|P|G|D|      (6)     |     (10)       |  // 确认/发送距离
+-------------------------------+-------------------------------+
|                      Session verify code                      |  // CRC32会话校验
+---------------------------------------------------------------+

注：
    长度：20 字节
    端口：UDP报头指定（4）



字段说明
========

-----------------------------------------------------------------------
(2) Data ID #SND
	发送方
	------
	发送方发送的一个数据体的当前唯一标识。
	在一个交互期中，最初的那个数据体的ID是随机的，之后的数据体ID按顺序递增编号。
	编号容量为16位（64k），会回绕。因此当前在传的数据体数量有限，但已足够大。
	注：
	现实的情况下，很难容许一个端点在同一条线路上同时传输6万多个数据体。
	而且这些数据体可以是任意大小的。

(2) Data ID #RCV
	接收端
	------
	接收端回馈确认接收到的数据体的ID（即原 #SND）。
	注：
	它与同一个数据报里的「#SND」没有关系，只与其接收到的数据报相关。
-----------------------------------------------------------------------
(4) 序列号（Sequence number）。
	发送方
	------
	当前发送分组的序列号，按字节数增量编码（起始增量为0）。
	每个数据体的初始序列号随机，之后增量为数据报负载大小，超值回绕。

	在数据体传输过程中，路径MTU可能变化，因此数据报大小会适时调整。
	采用字节数计量便于发送方丢包重发处理，以及接收端对不同数据报的灵活取舍。
	- 如果MTU变小，重发可以仅对丢失的包简单拆分重发。
	  而按包计量则需重构全部后续包。
	- 接收端可以按字节偏移截取任意收到的包的数据，减少重发需求。
	  而按包计量则有包序号相同但数据不同的麻烦。

(4) 确认号（Acknowledgment number）。
	接收端
	------
	接收端对发送方发送的连续数据的确认，值为数据序列号+1。
	即：它是接收进度需要的下一个数据报的序列号（与传统TCP的ACK意义相同）。

	接收端可通过缓发确认以抑制发送方的发送速率。与确认距离一起，可用于评估丢包。
-----------------------------------------------------------------------
[4] 扩展重组-包数量（RPZ-ExtraSize）。
	丢包重发时，合并连续的小包。
	这是一个自动的优化措施，通常用于交互式通信里的大量小包传输或路径MTU变大时。
	注：
	重组包数量有限，但至少需要组合2个包（值1），最多16个（值15）。

[4+2] （保留未用）

[6] 标志位。
	5] REQ 请求标记。
	   设置本数据报为一个资源请求。
	   可由任何一方发起，但发起方需要同时提供一个接收器接口（Receiver）。
	   对端根据资源请求检索并返回响应数据，响应的数据报该位需清零。
	   即：
	   没有该标记的数据报将由请求相对应的接收器处理（而非资源检索）。

	4] SES 会话创建/更新（Session）。
	   这是一个安全性机制，在对端初次请求连系时创建或一定时间间隔后更新。
	   初次连系时的会话创建参考「会话校验」条目。
	   会话创建优先级较低，如果此时和对端仍有有效通信，会忽略该请求。
	   不定时的会话更新请求可由任一端发起，包含「更新请求/确认/通告」3个步骤。
	   注：
	   会话数据报还负责设定下一个交互期初始数据ID的值（随机）。
	   没有会话校验码的新建会话请求可能是一个攻击，故优先级较低。

	3] BYE 结束告知。
	   通知数据体发送或其它事情已经结束。
	   它用于一个数据体全部发送完成并收到接收端的END确认后，正式结束的告知。
	   此告知只会发送一次。然后该数据体的发送服务即退出。

	   同时，它也用于对端离开时的告知。友好地通知对方自行善后。
	   此时数据ID #SND 和 #RCV 为一个特殊值 0xffff（全部之意）。
	   由于保活机制的存在，此BYE消息不等待对方的确认，通常连发两个Bye。
	   注：
	   此也为强制断开连系，即便数据尚未传输完毕（若会话有效）。

	接收端
	------
	2] RTP 请求重传（Retransmit Packet）。
	   请求发送方重发某个具体的包。
	   确认号即为请求的目标数据包的序列号（期待的下一个序列号）。
	   这通常在END包已收到但中间尚有缺失的情况下出现，以帮助迅速完成该数据体。
	   或者在小数据体传输中，发送方因无法获得足够的确认距离评估重发，而由接收端主动请求。
	   注：
	   - 未接收到END包即说明还有数据待发送。
	   - 接收端的超时很短。取收到的前2个包的时间间隔的2-3倍（约20-30ms）。
	   - 将重传主动权交给接收端似乎很合理：没收到就说一声嘛... :)
	   注记：
	   此时的确认距离没有意义，通常为零。

	发送方
	------
	1] BEG 分组开始（Begin）。
	   标记数据体的第一个分组数据报。

	0] END 分组结束（End）。
	   标记数据体的最后一个数据报，即分组结束。
	   如果数据包较小而无需分组，则BEG和END会被同时设置。

[6] 确认距离（ACK distance）。
	接收端
	------
	从当前进度的确认号之后，收到的非连续包的数量。0表示连续，无漏包。
	该值并不能表达所收到的数据报顺序，但它可以表达丢包概率，理想情况下该值为0。
	首个包的确认距离为0。如果未收到，后续包会从1开始计数。
	注记：
	确认号始终被赋值为积累ACK的下一个所需的序列号，否则无法从确认距离计算出来。

[10] 发送距离（Send distance）。
	发送方
	------
	当前发送的分组与确认分组的距离（包数量）。
	它表达了预发送的「超额」情况。
	接收端可以据此估算自身发送确认的到达情况（无法准确），以评估再次确认。
	预发送更有弹性，该字段占用前一字节的2比特位，以提升容量空间（1k）。
	注：
	每个数据体有自己的进度控制，公共的首个分组的顺序发送保证基本公平性。
-----------------------------------------------------------------------
(4) 会话校验码（Session verify code）。
	用于两个端点的当前连系认证和数据校验。
	流程：
	- 请求方在初始的会话申请中，创建一个随机的16字节token存放于负载前段。
	- 服务端回应一个8字节的会话码code和8字节的校验和：CRC64(token+code)。
	- 请求方根据该信息验证服务端的准确性。
	- 最终的会话校验码为：CRC64(code+token)。

	该校验码由双方保存，不再在网络上传输。之后的数据传输用一个固定的方式计算CRC32校验和。
	算法：
	CRC32(
		会话校验码 +
		数据ID #SND + 数据ID #RCV +
		序列号 + 确认号 +
		确认距离 + 发送距离 +
		数据
	)
	每一次的该值都会不一样，它既是对数据的校验，也是会话安全的认证。
	纯ACK确认时数据为空，但其它字段依然提供了可变性。
	注意
	- 这仅提供了简单的安全保护，主要用于防范基于网络传输的攻击。
	- CRC32仅用于小数据量的校验，更大的数据负载可由上级应用负责。
-----------------------------------------------------------------------
