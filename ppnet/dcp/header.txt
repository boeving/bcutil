报头结构
========

0                              15                              31
+-------------------------------+-------------------------------+
|          Data ID #SND         |        Sequence number        |  // 4字节，发送方设置
+-------------------------------+-------------------------------+
|     Data ID #RCV / RST-Beg    |   Receival number / RST-End   |  // 4字节，接收端/发送方设置
+-------------------------------+-------------------------------+
| RPZ-  |  ...  |.|R|S|B|R|R|B|E|              |                |  // 4字节
| Extra |  ...  |.|E|E|Y|T|S|E|N| ACK distance |  Send distance |  // 共
| Size  |  (4)  |.|Q|S|E|P|T|G|D|      (6)     |     (10)       |  // 32 bits
+-------------------------------+-------------------------------+
|                      Session verify code                      |  // 4字节，CRC32校验
+---------------------------------------------------------------+

注：
    长度：16 字节
    端口：UDP报头指定（4）



字段说明
========

-----------------------------------------------------------------------
发送方
------
(2) 发送数据ID #SND。
	一个数据体的当前唯一标识。
	在一个交互期中，最初的那个数据体的ID是随机的，之后的数据体ID顺序编号。
	编号容量为16位（64k），编号会回绕，因此在传数据的容量是有限的，但已足够大。
	注：
	现实的情况下，很难容许一个端点在同一条线路上同时传输6万多个数据体。
	而且这些数据体可以是任意大小的（非指分组数据报）。

(2) 序列号（Sequence number）。
	当前发送分组的序列号。
	以分组的数据报为单位计数（而非字节数）。
	数据报的大小与MTU有关，因此实际传输的数据量可能会很大。2字节足以表达。
	每个数据体的初始序列号随机，之后的分组按顺序递增，超值回绕。

	序列号与发送数据ID一起，标识特定数据体的具体某个数据报。
-----------------------------------------------------------------------
接收端
------
(2) 接收数据ID #RCV。
	含义同上，为对发送方数据的确认，值为其数据ID-SND。
	它与同一个数据报里的「数据ID-SND」没有关系，只与接收到的数据报相关。

(2) 接收号（Receival number）。
	对端对本端发送的响应数据的接收标记，值为收到的数据报的序列号。
	它是对接收到的当前包的确认，而非连续的进度位置的标号（如传统ACK）。
	它与确认距离一起，可计算出进度位置的确认号。
	另：
	接收端可以通过缓发确认抑制发送方的发送速率。
-----------------------------------------------------------------------
[4] 扩展重组-包数量（RPZ-ExtraSize）。
	丢包重发时，合并连续的小包。
	这是一个自动的优化措施，通常用于交互式通信里的大量小包传输或路径MTU中途变大时。
	该值需配合RST标志使用，以通知接收端重置接收。
	注：
	重组包数量有限，但至少需要组合2个包，最多16个（1-15）。
	单包的简单重传无需设置重置标记，与本区域无关。

[4] （保留未用）

[8] 标志位。
	7] （未用）
	----------
	6] REQ 请求标记。
	   设置本数据报为一个资源请求。
	   可由任何一方发起，但发起方将成为响应数据的接收者。
	   对端根据资源请求检索并返回响应，响应的数据报该位需清零。
	   即：没有该标记的数据报由请求相对应的接收器处理（而非资源检索接口）。

	5] SES 会话创建/更新（Session）。
	   这是一个安全性机制，在对端初次请求连系时创建或一定时间间隔后更新。
	   初次连系时的会话创建参考「会话校验」条目。
	   会话创建优先级较低，如果此时和对端仍有有效通信，会忽略该请求。
	   不定时的会话更新请求可由任一端发起，包含「更新请求/确认/通告」3个步骤。
	   注：
	   会话数据报还负责设定下一个交互期初始数据ID的值（随机）。
	   没有会话校验码的新建会话请求可能是一个攻击，故优先级较低。

	4] BYE 断开（Bye!）。
	   友好地主动说再见，通知对方事情已经结束。
	   它用于一个数据体全部发送完成并收到接收端的END确认后，正式结束的通知。
	   此时的接收号设置为 0xffff（意为全部分组）。

	   同时，它也用于对端离开时的告别。通知对方以自行善后。
	   此时数据ID全为一个特殊值 0xffff（意为全部数据）。
	   由于保活机制的存在，告别消息不再等待对方的确认（通常连发两个Bye ^.^）。
	   注：
	   即便数据尚未传输完毕，对方也视为放弃连系（若会话有效）。

	接收端设置
	----------
	3] RTP 请求重传（Retransmit Packet）。
	   请求发送方重发某个具体的包。
	   接收号即为请求的目标数据包的序列号。
	   这通常在END包已收到但中间包缺失的情况下有用。它可以帮助迅速完成该数据体，从而有利于应用的并行处理。
	   或者在单独的小数据体传输中，因发送方无法获得足够的确认距离评估重发，由接收端超时后申请。
	   注：
	   - 未接收到END包即说明还有数据待发送。
	   - 接收端的超时通常很短：前2个包间隔的2-3倍（最短10-15ms）。
	   - 将重传主动权交给接收端似乎很合理：没收到就说一声嘛... :)
	   - 此时的确认距离没有意义，通常为零。

	发送方设置
	----------
	2] RST 重置（Reset）。
	   通知对方重置接收。
	   当发送方探测到路径MTU减小，会自动调整发送的数据包大小。
	   但如果同时判断有丢包，则自该丢失包的序列号起，后续数据包需按新的大小重新构造。
	   此时新的小数据包会有重置标记，通知接收端重新接收。

	   重置标记一直持续，直到数据量累计达到重置前发送最后一个包时的数据量。
	   如果此段时间内再次出现MTU减小，则重置整个数据体的发送。
	   注：
	   因为丢包后的重发拆分会导致序列号混乱故需重置。
	   重置仅仅只是重构数据为不同大小的分组，而不是新的数据。

	1] BEG 分组开始（Begin）。
	   标记数据体的第一个分组数据报。

	0] END 分组结束（End）。
	   标记数据体的最后一个数据报，即分组结束。
	   如果数据包较小而无需分组，则BEG和END会被同时设置。

[6] 确认距离（ACK distance）。
	接收端设置。
	当前收到分组的接收号与确认号的差。1表示连续，2表示跳了1个包。
	理想情况下该值为1，但如果接收到多个跳跃包，则可能发送的丢包了。
	如果首个包就未收到，无法计算确认距离，则值为0，表示首个包未收到。
	注：
	确认号表达了实际的进度，非传统积累ACK的序列号+1的含义。
	零值为特殊值，表示无法计算或首个包就未收到。

[10] 发送距离（Send distance）。
	发送方设置。
	当前发送的分组序列号与确认号（进度）的距离。
	此也为发送方对最终确认（ACK已收到）的通报，即对ACK确认的确认。
	该值能表达初始RTT和ACK丢失状况。
	该字段占用前一字节2位比特，以提升容量空间（1k）。
	注：
	进度是对「有序的数据体 + 每个数据体有序分组」的确认。
	每个数据体进度的公共部分由其首个分组对应的「数据体序列位置点」决定。
	就像一条链上顺序悬挂了各个数据体分组，每条路径的公共部分叠加延长。
-----------------------------------------------------------------------
(4) 会话校验码（Session verify code）。
	用于两个端点的当前连系认证和数据校验。
	应用初始申请一个会话时，对端发送一个8字节随机值作为验证前缀。
	该验证前缀由双方保存，不再在网络上传输。
	之后的数据传输用一个固定的方式计算CRC32校验和，算法：
	CRC32(
		验证前缀 +
		数据ID #SND + 序列号 +
		数据ID #RCV + 接收号 +
		发送距离 + 确认距离 +
		数据
	)
	每一次的该值都会不一样，它既是对数据的校验，也是会话安全的认证。
	纯ACK确认时数据为空，但其它字段依然提供了可变性。
	注：
	- 这仅提供了简单的安全保护，主要用于防范基于网络传输的攻击。
	- CRC32仅对不超过64kb的数据报校验，更大的数据负载由上级应用自行负责。
-----------------------------------------------------------------------
