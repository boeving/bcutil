DCP（Datagram Control Protocol）数据报控制协议
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
基于UDP实现一个「完整数据」传送的逻辑，类似于文件，有边界。
主要用于P2P的数据传输。

下面，完整的数据称为「数据体」，被分解传输的分片数据称为分组或数据报。
注：极小的数据体通常无需分解。


目标
====
1. 并行传输。
   一个数据体对应用而言是一个字节流，但多个数据体并行发送。
   接收端也为并行接收，应用并行处理。

   与传统TCP一对客户端/服务器的连接逻辑不同，一个端点同时充当客户和服务器并同时实施。
   即端点通过一条链路发送客户请求并获取响应的同时，也接收对端的请求并提供响应服务。
   注：
   自身的响应数据和对对端响应数据的确认可在同一个数据报中发送，使得网络链路效益更高。
   这是一种逻辑上的双工，在链路上类似于双双工。

2. 送达可靠性。
   保证数据完整送达，包含简单的数据可靠性保证。
   注：如果数据敏感或包含隐私，应用自行负责更强的安全措施（如加密）。

3. 重发/拥塞控制。
   轻启动，预发送，乱序间距回馈，速率自适应，ACK滞速控制。
   与TCP借助于准确的ACK回馈不同，此借助于预发送的多包间距回馈获知数据传输状况，
   和接收端的滞速要求（注：没有窗口逻辑）。
   发送方的丢包判断主要依据「确认距离」，辅以接收端的主动重发请求和很少用到的超时设计，
   注：
   - 发送方超时仅在极小数据体的单次交互中触发（因为缺乏判断参考）。
   - 接收端的超时时长极短，为前2个包间距的2～3倍，通常在30ms以内。


注：
	在传统的客户/服务器逻辑里，两个方向传输的数据量通常差异较大，
	这样就使得对对方数据的确认同时附带数据的情形偏少，降低了网络链路的效益。
	在P2P环境里，相互需要数据的逻辑基本上是对等的。因此确认携带数据的情形就比较常见。
	通过良好的应用设计TCP也能实现这种效果，但本协议自然蕴含了这种处理方式。

	数据的传送类似于一种「连续流」，它不太适用于依赖对端响应数据的发送，
	即本端后续发送的数据需要由前一个数据的响应来决定的「紧密交互」情形。


基本逻辑
========
1. 顺序并发。
   数据ID按应用请求的顺序编号，并顺序发送其首个分组。之后各数据体自行发送。
   数据体以自身动态评估的即时速率顺序发送自己的分组，不等待确认，获得并行效果。
   数据体的速率评估会间接作用于全局基准速率（基准线）。

   交互期内起始的数据体的数据ID随机产生，数据体内初始分组的序列号也随机。
   注：
   首个分组按顺序发送可以使得接收端有所凭借，而不是纯粹的无序。
   这样，极小数据体（仅有单个分组）在接收端的丢包判断就很容易了（否则很难）。

2. 乱序接收。
   网络IP数据报传输的特性使得顺序的逻辑丢失，因此乱序是基本前提。
   每个数据体内的分组由序列号定义顺序，按此重组数据体。
   发送方数据体的发送是一种并行，因此接收可以数据体为单位并行写入应用。

3. 乱序确认。
   接收端按自身的节奏确认抵达的数据报，无顺序要求。
   每个数据体的应用写入的性能可能不同，通过确认回复制约发送方的发送速率。

   如果已经收到END包但缺失中间的包，可主动请求重发以尽快交付数据体。
   丢包判断并不积极（除非已收到END包），采用超时机制：前2个包间隔的2-3倍（很短）。
   注：尽量减轻不必要重发的网络负担。
   从「发送距离」可以评估确认是否送达（ACK丢失），必要时再次确认。

4. 有序重发。
   每个数据体权衡确认距离因子计算重发。
   序列号顺序依然决定优先性，除非收到接收端的主动重发请求。


概念
====
与UDP相同，本协议中没有连接的概念，端点可以向任意目标端直接发送数据。一对已经穿透NAT并保持通信状态的端点可称为一个「连系」。
就像TCP建立连接的握手，建立一个连系需要打个招呼，它是一次会话申请和一次会话确认。
会话确认初始化验证数据，为接下来的通信提供基本的安全保障。
因为NAT的原因，连系有保活的概念，主动断开可以发送1-2个Bye包（无需确认）。同时，如果不活了也就断开了。

连系
----
	通过某些中介获得对端的地址信息（IP:Port），发送会话申请建立一个连系。
	连系不是连接。连接是一种状态，连系是一种松散的关系约定，更像是一种「存在」。

	如果向对方发起数据请求（查询），则开启了一个交互期（见下）。


交互期
------
	两个端点相互传递数据，彼此尚未全部交付的时间段称为「交互期」。
	当彼此的数据都全部完成后，称为一个交互期结束。
	每个交互期是一个完整的传输逻辑，再次启动传输即为开启一个新的交互期。
	（注：有点类似于TCP中的一次连接）

	每个交互期的起始数据ID是一个随机值，之后按顺序编号，存在顺序的逻辑。
	起始数据ID的随机性是一个辅助的安全措施。


轻启动
------
	起始数据报大小取固定最小值，然后依MTU通告/确认进行调整。
	起始的数据发送速率也较慢，之后根据距离回馈评估进行自适应。
	初始数据报大小：576 bytes
	初始发送速率：  5 ms/packet
	注：
	由确认距离和己方的发送速度可评估网络状况。


ACK滞速
-------
	当前发送包与进度线的距离制约发送的速率，距离越大发送越慢。

	接收端可以通过缓发ACK来降低发送方的发送速度：当新的包到达时不再返回ACK确认。
	这与即时返回新包的ACK但进度线保持不变不同，确认距离的加大会让发送方评估为丢包。

	这里有一个例外：
	单包（数据体未分解）的ACK确认会及时返回，以优化交互式通信的效率（如ssh）。


评估重发
--------
	如果发送方收到的回馈包里确认距离加大，也即进度线未移动，说明很可能已经丢包。
	则会触发距离起点的包重发（通过距离和确认号即可计算出来）。
	这是常见的情形。

	如果数据体本来就小，同时缺乏后续其它数据的连续发送而无法体现「距离」，
	此时的丢包就只能由接收端主动的请求重发了。

	重发的距离判断与发送的速率本身有关：速率越高容忍的距离越大（注：速率会被动态修订）。


超时重发
-------
	对于一个交互期内只有一个极小的数据体发送（如1~2数据报）的情形，
	因为可能极少的几个数据报同时丢失，从而使得接收端无法评估丢包情况。
	此时会触发超时重发机制。通常这很少发生。

	因为极少发生，超时重发采用简单的2倍指数退避方式，
	最高延时2分钟，按500ms初始超时值计算，最多产生8次重发。

	如果后续出现新的数据发送，该重发数据被合并入一个新的交互期。
	因此也就不再容易触发超时了。


速率评估
--------
	主要从距离进行评估，参考数据量权衡基准速率。
	距离：
	 - 发送距离越大，是因为对方确认慢，故减速。
	 - 确认距离越大，丢包概率越大，故减速。设置丢包认可。
	数据量：
	 - 数据量越小，基准速率向慢（稳）。降低丢包评估重要性。
	 - 数据量越大，基准速率趋快（急）。丢包评估越准确。
	因子变量：
	 1. 基线。即基准速率的自动调优值。
	 2. 斜率。速率增幅，越接近基线则越慢。
	 3. 跌幅。丢包之后的减速量（快减），拥塞响应。


动态速率
--------
	基准速率乘以一个1.0上下波动的变量q即为动态速率。
	发送距离越大，q值越小，实现降速的目的。反之则为加速。
	q值被按一定节奏地更新，评优、记忆，以实现发送速率的自适应。


缓增骤减
--------
	如果MTU改变，增大时数据报会变大，此时会立即降速。
	降速参考MTU改变前的带宽，然后逐渐提速。通常约3秒充满新的带宽。

	MTU减小时表示带宽缩减，数据报会变小。
	此时速率不变，总的数据量表现为骤减。之后速率自适应。


确认延时
--------
	接收端收到数据后并不是立即返回ACK确认，它有一个基本延时。
	这个延时用于优化ACK的合并，以及收集接收端的应用数据（携带发送）。
	该值应当是用户可设置的。


流式模拟
--------
	如果需要转换为传统TCP的「流式」逻辑，由外部应用主动读取/写入。
	可实现一个缓存子服务。
	服务端：
	- NewReader 返回的Reader从内部缓存读取，始终不会输出io.EOF。
	客户端：
	- Receive 通过缓存转换，提供流式读取接口。

	缓存调优：
	- 应用读取速率评估；
	- 在传数据量（容量基线，RTT相关）；


会话校验
--------
	攻击者可能伪造大量不同源IP向同一服务端提交请求，试图激发大量客户端向同一服务器产生反应。
	采用会话校验码避免：
	- 请求方在初始的会话申请中，创建一个随机的16字节token存放于负载前段。
	- 服务端回应一个8字节的会话码code和8字节的校验和：CRC64(token+code)。
	- 请求方根据该信息验证服务端的准确性。
	- 最终的会话校验码为：CRC64(code+token)。
	即：
	如果想要窃取会话校验码，攻击者必须同时截获初始连系的往返两个数据报。


流程
====
	客户端：
	应用请求 >> [发送]；[接收] >> 写给应用。

	服务端：
	[接收] >> 询问应用获取io.Reader，读取 >> [发送]。

	注：
	1. 发送指发送数据到网络，接收指从网络接收数据。
	2. 回调模式无需缓存（故无窗口）。


参数
====
	lineCaps: n			容量基线（数据报个数）。在传数据容量，类似带宽时延积
	baseRate: 5ms		基础速率。初始默认发包间隔
	minRate: 100μs 		极限速率。万次/秒
	rateUpdate: 500ms 	速率更新间隔
	aliveTime: 120s		保活时间界限
	aliveIntvl: 10s		保活报文间隔时间
	aliveProbes: 6		保活探测次数上限


参考
====

接收端RTT估算
-------------
	发送方收到新的进度线ACK后，会立即发送新的数据（如果有），
	因此接收端可据此估算RTT值。
	注：
	发送方没有对RTT值的需求。发送速率由接收端制约（间接控制）。


接收端对发送速率的估算
----------------------
	发送方初始为基于基准速率的匀速发送，直到收到第一个ACK确认。
	初始发送的数据报的发送距离为一个特殊值 0xff（表示无效）。
	当收到首个ACK确认后，记录一个「容量基线」值，即为数据在网络上的在线容量。
	此时的发送距离记为0。
	之后的发送包的发送距离在此系统基础上计算。

	源于此规则，接收端可以从收到的首个报文和首个0距离的报文估算平均的发送速率：
	（报文数量/时段长）。

	注：
	- 值0xff在距离中不用，它表示距离无效（缺乏参考点）。
	- 容量基线是由收到的首个ACK计算而来的，因为它可能并不是首个发送包的确认。


长时间间隔之后的再次传输
------------------------
	两个端点间较长时间未传输数据后，网络状态变化，情况未知。
	此时新的基准速率取值：
		（前阶最佳基准线 + 系统默认基准线）/ 2
	数据报大小取前阶值。



接口设计
========
1.
缺失的分组可能可以忽略（如视频），因此支持跳过缺失的确认。
函数：
	// 忽略当前缺失的分组，跳至最接近的后段分组。
	// 返回跳过的分组数。
	func Ignore() int

	// 返回进度线与最近后段分组的距离。
	func Space() int


2.
在一个连系上支持并行发送，可以降低对系统的要求。如端口数，新连系的NAT穿透与保活等。
但数据体的独立处理方式让小数据体（几个分组）难以通过距离评估。

为缓解这一问题，客户端可以自定义数据体的逻辑，即可以将多个小数据体的逻辑合并为一个。
这通过请求查询时提供相同的数据名称来实现。
函数：
	// 名称绑定到数据ID，名称不变则数据ID不变。
	func Query(name string, res []byte, rec Receiver)



注记
===============================================================================
每个数据体在自己的一个Go程内管理发送逻辑，发送距离有255的最长限制。
而把数据报实际写入网络是由一个发送总管负责，以保持有规律的发送间隔（速率）。
发送总管从一个信道中获取待发送的数据，没有长度限制。其速率由各数据体Go程协调控制。




数据流图
===============================================================================

       (B Peer)     |                                   |      (A Peer)
                    |                                   |
                    |                                   |
   +---> servSend   |                                   |   recvServ ----+
   |         |      |                                   |      A         |
   |         |      |                                   |      |         | AckReq
   |         |      |                                   |      |         | (Rcv, Dist,RTP)
   |         V      |                                   |      |         |
   +--- +---------+ |                                   | +---------+ <--+
        | service | | <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< | | xSender | <~~~~~ Request
 ~~~~~> | xSender | | >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> | | service |
   +--> +---------+ |                                   | +---------+ ---+
   |         |      |                                   |      A         |
   |         |      |                                   |      |         | Rcv, Dist
   |         |      |                                   |      |         | (速率控制)
   |         V      |                                   |      |         |
   +---- recvServ   |                                   |   servSend <---+
                    |                                   |
                    |                                   |

1. Request(A):
	应用客户发起资源请求。

2. xSender(A):
	分配数据体ID，创建该数据体接收服务实例（recvServ）。
	发送请求数据报，可携带对端响应数据的确认（Ack）。

3. service(B):
	接收网络数据报，解析分配工作任务：
	- 为资源请求时，创建数据体发送服务实例（servSend）并提交资源请求。
	- 若A已向B发送过资源请求，则数据报可能为对端响应的数据。交由接收服务实例（recvServ已创建）。

--- 以下为并行逻辑

4. servSend(B):
	从注册的服务应用读取响应数据；
	根据接收号（Rcv）和确认距离（Dist）评估休眠时间（发送速率）；
	向 xSender 递送构造好的数据报。

5. recvServ(B):
	接收对端的响应数据，写入请求时提供的应用接收器（Receiver）；
	根据应用接收器对数据的消耗速度自行决定确认进度，约束对端的发送速率。

--- 以下回归发送总管（xSender）

6. xSender(B):
	- 获取数据体发送服务的响应数据报；
	- 获取接收器的确认申请或重发请求申请；
	组合响应数据报和确认（重发请求）申请，发送数据报。

7. service(A):
	参考如上第3点。互发和循环。
