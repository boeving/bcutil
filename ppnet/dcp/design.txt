DCP（Datagram Control Protocol）数据报控制协议
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
基于UDP实现一个「完整数据」传送的逻辑，因此类似于文件，有边界。
主要用于P2P的数据传输。

在下面，完整的数据称为「数据体」，被分解传输的分片数据称为分组或数据报。
注：视数据大小也可能无需分解。


目标
====
1. 任意尺寸数据体。
   分组并行发送（多路复用）。
   一个数据体对应用而言是一个字节流。但支持多个数据体并行送达。
2. 送达可靠性。
   保证数据报送达，提供简单基础的数据可靠性。
   通常，如果数据敏感或包含隐私，应用应采取更强的安全措施（如哈希校验/加密）。
3. 重发/拥塞控制。
   轻启动，预发送，乱序间距回馈，速率自适应，ACK滞速控制。
   与TCP借助于准确的ACK回馈不同，此借助于预发送的多包间距回馈获知数据传输状况，
   和接收端的滞速要求（注：没有窗口逻辑）。
   发送方的丢包判断依据「确认距离」（注：无超时设计），辅以接收端的主动重发请求，
   解决小数据体的末尾依据问题，以及并行优化。
   注：
   接收端有超时设计但时长极短（前2个包间距的2～3倍）。


基本逻辑
========
1. 顺序并发。
   不同的数据体按请求的先后顺序编号，无需等待确认连续发送。
   总的发送速率受接收端各数据体的ACK滞速综合调控。
   每个数据体内部分组的丢包重发由确认距离和接收端主动请求控制，对速率间接影响。
   注：数据体独立发送，每个都有255的间距容量。
2. 乱序接收。
   网络传输无法保证数据报原始的顺序是一个天然特征，因此我们以乱序为设计前提。
   每个数据体内部的分组有严格的顺序，但数据体之间无此约束。
3. 乱序确认。
   按适当的节奏确认抵达的数据报，无顺序要求。
   从「发送距离」中我们可以评估确认是否送达（ACK丢失），如果必要重新发送确认。
4. 有序重发。
   权衡确认距离因子计算重发，序列号顺序依然决定优先性。
   除非收到接收端的主动重发请求（最高优先性）。

小结：
发送方有序基础上的并发（模拟），接收端以无序为前提。


报头结构
========
	0                              15                              31
	+-------------------------------+-------------------------------+
	|          Data ID #SND         |        Sequence number        |  // 4字节，发送方设置
	+-------------------------------+-------------------------------+
	|          Data ID #RCV         |     Acknowledgment number     |  // 4字节，接收端设置
	+-------------------------------+-------------------------------+
	| RPZ-  | MTU-  |R|R|S|R|B|R|B|E|               |               |  // 4字节
	| Extra | ANN/  |E|S|E|S|Y|T|E|N|  ACK distance | Send distance |  // 共
	| Size  | ACK   |Q|P|S|T|E|P|G|D|               |               |  // 32 bits
	+-------------------------------+-------------------------------+
	|                      Session verify code                      |  // 4字节，CRC32校验
	+---------------------------------------------------------------+
	|                        MTU Custom size                        |  // 4字节，可选
	+---------------------------------------------------------------+

	长度：16 + 4 可选
	端口：UDP报头指定（4）

说明
----
	-----------------------------------------------------------------------
	发送方
	------
	(2) 数据ID #SND。
		对一个完整数据的标识。
		类似于一个文件描述符，返回给应用层用于标记数据。
		多个数据传输并行工作，类似多文件请求。
	(2) 序列号（Sequence number）。
		以分组的数据报为单位，而非字节数。
		初始发送时起始值随机，随后的分组按顺序递增，超值回绕。
		与数据ID一起工作。
		注：0xffff 为特殊值不用。
	-----------------------------------------------------------------------
	接收端
	------
	(2) 数据ID #RCV。
		含义同上，为对发送方数据的确认，值为其数据ID-SND。
		它与同一个数据报里的「数据ID-SND」没有关系，只与接收到的数据报相关。
	(2) 确认号（Acknowledgment number）。
		完整进度需要的下一个序列号（即传统的ACK含义）。
		接收端通常并不会立即返回确认。
		通过返回ACK的时间控制，接收端可以影响发送端的速率。
		注：0xffff 表示单纯的发送，无数据可确认。
	-----------------------------------------------------------------------
	[4] 扩展重组-包数量（RPZ-ExtraSize）。
		重发时对非满载包的重新组合，仅限于同一个数据体的连续分组。
		通常用于交互式通信场景。
		默认值0，表示无重组发生，1表示添加了一个包（共2个包组合）。
		最大值15支持共16个包重组。
	[4] MTU 通告/确认（MTU-ANN/ACK）。
		告诉对端自己可以发送的最大包尺寸。
		确认时可设置更小的类型，以声明自己的处理能力（MTU，MSS 二合一）。
		确认仅在对方设置非零值时产生，回应零值表示忽略（维持原值）。
		注：4位空间可支持14种标准通路，值15特殊用途。
		0) 协商保持。
		   保持之前协商的数据报大小。默认状态。
		1) 基础值。也为初始轻启动的值。
		   576 （x-44 = 532/IPv4，x-64 = 512/IPv6）
		2) 基础值2。IPv6默认包大小。
		   1280（x-64 = 1216/IPv6）
		3) PPPoE链路。
		   1492（x-44 = 1448/IPv4，x-64 = 1428/IPv6）
		4) 常用以太网通路。
		   1500（x-44 = 1456/IPv4，x-64 = 1436/IPv6）
		15) 超标指示。
			由头部后4字节指定大小，常用于超高速网络。
		注记：
		- MTU测试实现为一个独立的服务，每隔一段时间（10～20分钟）重复执行。
		  外部简单调用取值即可。
		- 对于超高速网络，通常传输能力已知，无需测试，仅简单协商。
		- 一次单向通告产生往返2个数据报，双向则有4个，无法合并。
		  通告通常仅在初始联系或MTU发生变化时才产生。
	[8] 标志位。
		双方可设置
		----------
		7] REQ 标记请求。
		   设置本数据报为一个资源请求。
		   它将由服务端检索查询并返回响应（与RSP标记对应）。
		6] RSP 数据响应。
		   响应客户的查询请求，返回响应数据。
		   它与REQ标记一起，用于区分数据报的处理接口（数据接收或资源检索）。
		5] SES	会话创建/更新（Session）。
		   这是一个安全性机制，在对端初次请求连系时或一定时间间隔后发生。
		   初次连系时的会话创建由接收请求的一方设置。
		   不定时的会话更新请求可由任一端发起，包含「更新请求/确认/通告」3个步骤。
		   原则上，会话更新包不携带数据（可能更快送达）。
		4] RST 	状态重置（Reset）。
		   通知对方重置发送，如果SES同时置位，则同时也清除会话。
		   如果未携带合法的会话校验码，则有较低的优先级，否则立即重置。
		   这可能是在接收端当机重启后，丢失前阶的会话和数据标识时发生。
		   注：
		   - 缺失会话校验码的重置请求这可能是一个攻击。
		   - 如果依然继续接收到对方合法的数据发送或确认，则忽略该请求。
		3] BYE	主动断开（Bye!）。
		   友好地，双方可以主动说再见，以通知对方自己离开了，请自行善后。
		   源于保活机制的存在，这一消息无需等待对方确认（可连发两个Bye）。
		   注：
		   即便数据尚未传输完毕，对方也视为放弃连系（会话有效）。
		接收端设置
		----------
		2] RTP	请求重传（Retransmit Packet）。
		   请求对端发送某个具体的包。
		   确认号即为请求的目标数据包的序列号。
		   这通常在END包已收到但中间包缺失的情况下有用。它可以帮助迅速完成该数据体，从而有利于应用的并行处理。
		   或者在单独的小数据体传输中，因发送方无法获得足够的确认距离评估重发，由接收端超时后申请。
		   注：
		   - 未接收到END包即说明还有数据待发送。
		   - 接收端的超时通常很短：前2个包间隔的2-3倍（最短10-15ms）。
		   - 将重传主动权交给接收端似乎很合理：没收到就说一声嘛，你的ACK肯定是弄丢了^9^...
		发送方设置
		----------
		1] BEG  分组开始（Begin）。
		   标记数据体的第一个分组数据报。
		0] END  分组结束（End）。
		   标记数据体的最后一个数据报，即分组结束。
		   如果数据包较小而无需分组，则BEG和END会被同时设置。
	(1) 确认距离（ACK distance）。
		接收端设置。
		当前收到的分组与进度线的距离。如：1表示跳了1个包。
		理想情况下该值为0，但如果接收到多个跳跃包，则可能发送方丢包了。
		注：
		进度线指连续无间隔的确认号的最新位置，即传统的积累ACK确认。
	(1) 发送距离（Send distance）。
		发送方设置。
		当前发送的分组序列号与进度线的距离。
		此也为发送方对接收端的进度通报，即对方发送的ACK已收到（对ACK确认的确认）。
		该值能表达初始RTT和ACK丢失状况。
	-----------------------------------------------------------------------
	(4) 会话校验码（Session verify code）。
		用于两个端点的当前连系认证和数据校验。
		应用初始申请一个会话时，对端发送一个8字节随机值作为验证前缀。
		该验证前缀由双方保存，不再在网络上传输。
		之后的数据传输用一个固定的方式计算CRC32校验和，算法：
		CRC32(
			验证前缀 +
			数据ID #SND + 序列号 +
			数据ID #RCV + 确认号 +
			发送距离 + 确认距离 +
			数据
		)
		每一次的该值都会不一样，它既是对数据的校验，也是会话安全的认证。
		纯ACK确认时数据为空，但其它字段依然提供了可变性。
		注：
		这仅提供了简单的安全保护，主要用于防范基于网络性能的攻击。
		对于重要的数据，应用应当自行设计强化的安全措施。
	-----------------------------------------------------------------------
	(4) MTU 自定义大小（MTU Custom size）
	    当MTU通告区域值为0xff时，指定的MTU大小。单位为字节。
		该字段可选（不常用）。
	-----------------------------------------------------------------------


概念
====
与UDP相同，本协议中没有连接的概念，端点可以向任意目标端直接发送数据。一对已经穿透NAT并保持通信状态的端点称为一个「连系」。
就像TCP建立连接的握手，建立一个连系需要打个招呼。它是一次Hello和一次会话确认，会话确认初始化验证数据，为接下来的通信提供安全保障。
因为NAT的原因，连系有保活的概念，但无「断开」的必要。不活了也就断开了。


轻启动
------
	起始数据报大小取固定最小值，然后依MTU通告/确认进行调整。
	起始的数据发送速率也较慢，之后根据距离回馈评估进行自适应。
	初始数据报大小：576 bytes
	初始发送速率：  5 ms/packet
	注：
	由确认距离和己方的发送速度可评估网络状况。


ACK滞速
-------
	当前发送包与进度线的距离制约发送的速率，距离越大发送越慢。

	接收端可以通过缓发ACK来降低发送方的发送速度：当新的包到达时不再返回ACK确认。
	这与即时返回新包的ACK但进度线保持不变不同，确认距离的加大会让发送方评估为丢包。

	这里有一个例外：
	单包（数据体未分解）的ACK确认会及时返回，以优化交互式通信的效率（如ssh）。


丢包重发
--------
	如果发送方收到的回馈包里确认距离加大，也即进度线未移动，说明很可能已经丢包。
	则会触发距离起点的包重发（通过距离和确认号即可计算出来）。
	这是常见的情形。

	如果数据体本来就小，同时缺乏后续其它数据的连续发送而无法体现「距离」，
	此时的丢包就只能由接收端主动的请求重发了。

	重发的距离判断与发送的速率本身有关：速率越高容忍的距离越大（注：速率会被动态修订）。


速率评估
--------
	原则：距离越大，重发的概率越大。
	数据大/多，基准速率趋快（急），确认距离大，易丢包但也易及时弥补。
	数据越小，基准速率向慢（稳），确认距离会越小，重发判断也可行。
	算法因素：
	1. 基线。即基准速率的自动调优值。
	2. 斜率。速率增幅，越接近基线则越慢。
	3. 跌幅。丢包之后的减速量（快减），拥塞响应。


动态速率
--------
	基准速率乘以一个1.0上下波动的变量q即为动态速率。
	发送距离越大，q值越小，实现降速的目的。反之则为加速。
	q值被按一定节奏地更新，评优、记忆，以实现发送速率的自适应。


缓增骤减
--------
	如果MTU改变，增大时数据报会变大，此时会立即降速。
	降速参考MTU改变前的带宽，然后逐渐提速。通常约3秒充满新的带宽。

	MTU减小时表示带宽缩减，数据报会变小。
	此时速率不变，总的数据量表现为骤减。之后速率自适应。


确认延时
--------
	接收端收到数据后并不是立即返回ACK确认，它有一个基本延时。
	这个延时用于优化ACK的合并，以及收集接收端的应用数据（携带发送）。
	该值应当是用户可设置的。


流式模拟
--------
	如果需要转换为传统TCP的「流式」逻辑，由外部应用主动读取/写入。
	可实现一个缓存子服务。
	服务端：
	- NewReader 返回的Reader从内部缓存读取，始终不会输出io.EOF。
	客户端：
	- Receive 通过缓存转换，提供流式读取接口。

	缓存调优：
	- 应用读取速率评估；
	- 在传数据量（容量基线，RTT相关）；


流程
====
	客户端：
	应用请求 >> [发送]；[接收] >> 写给应用。

	服务端：
	[接收] >> 询问应用获取io.Reader，读取 >> [发送]。

	注：
	1. 发送指发送数据到网络，接收指从网络接收数据。
	2. 回调模式无需缓存（故无窗口）。


参数
====
	lineCaps: n			容量基线（数据报个数）。在传数据容量，类似带宽时延积
	baseRate: 5ms		基础速率。初始默认发包间隔
	minRate: 100μs 		极限速率。万次/秒
	rateUpdate: 500ms 	速率更新间隔
	aliveTime: 120s		保活时间界限
	aliveIntvl: 10s		保活报文间隔时间
	aliveProbes: 6		保活探测次数上限


参考
====

接收端RTT估算
-------------
	发送方收到新的进度线ACK后，会立即发送新的数据（如果有），
	因此接收端可据此估算RTT值。
	注：
	发送方没有对RTT值的需求。发送速率由接收端制约（间接控制）。


接收端对发送速率的估算
----------------------
	发送方初始为基于基准速率的匀速发送，直到收到第一个ACK确认。
	初始发送的数据报的发送距离为一个特殊值 0xff（表示无效）。
	当收到首个ACK确认后，记录一个「容量基线」值，即为数据在网络上的在线容量。
	此时的发送距离记为0。
	之后的发送包的发送距离在此系统基础上计算。

	源于此规则，接收端可以从收到的首个报文和首个0距离的报文估算平均的发送速率：
	（报文数量/时段长）。

	注：
	- 值0xff在距离中不用，它表示距离无效（缺乏参考点）。
	- 容量基线是由收到的首个ACK计算而来的，因为它可能并不是首个发送包的确认。


长时间间隔之后的再次传输
------------------------
	两个端点间较长时间未传输数据后，网络状态变化，情况未知。
	此时新的基准速率取值：
		（前阶最佳基准线 + 系统默认基准线）/ 2
	数据报大小取前阶值。



API支持
=======
1.
缺失的分组可能可以忽略（如视频），因此支持跳过缺失的确认。
伪代码：
	// 忽略当前缺失的分组，跳至最接近的后段分组。
	// 返回跳过的分组数。
	func Ignore() int

	// 返回进度线与最近后段分组的距离。
	func Space() int
