DCP（Datagram Control Protocol）数据报控制协议
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
基于UDP实现一个「完整数据」传送的逻辑，类似于文件，有边界。
主要用于P2P的数据传输。

下面，完整的数据称为「数据体」，被分解传输的分片数据称为分组或数据报。
注：极小的数据体通常无需分解。


特点
====
1. 并行传输。
   一个数据体对应用而言是一个字节流，但多个数据体则是一种并行关系。
   接收端也为并行接收，应用并行处理。

   与传统TCP客户端/服务器的一个连接不同，一个端点可同时充当客户和服务器（同时实施）。
   即：端点通过一条链路发送客户请求并获取响应的同时，也接收对端的请求并提供响应服务。
   自身的响应数据和对对端响应数据的确认在同一个数据报中发送，这使得网络链路效益更高。

   这是一种逻辑上的双工，与链路的双工叠加，获得一种「双双工」的效果。

2. 送达可靠性。
   保证数据完整送达，包含简单的数据可靠性保证。
   注：如果数据敏感或包含隐私，应用自行负责更强的安全措施（如加密）。

3. 重发/拥塞控制。
   轻启动，预发送，乱序间距回馈，速率自适应，ACK滞速控制。
   与TCP借助于准确的ACK回馈不同，此借助于预发送的多包间距回馈获知数据传输状况，
   和接收端的滞速要求（注：没有窗口逻辑）。
   发送方的丢包判断主要依据「确认距离」，辅以接收端的主动重发请求和很少用到的超时设计，
   注：
   - 发送方超时仅在极小数据体的单次交互中触发（因为缺乏判断参考）。
   - 接收端的超时时长极短，为前2个包间距的2～3倍，通常在30ms以内。


注：
	在传统的客户/服务器逻辑里，两个方向传输的数据量通常差异较大，
	这样就使得对对方数据的确认同时附带数据的情形偏少，降低了网络链路的效益。
	在P2P环境里，相互需要数据的逻辑基本上是对等的。因此确认携带数据的情形就比较常见。
	通过良好的应用设计TCP也能实现这种效果，但本协议自然蕴含了这种处理方式。

	数据的传送类似于一种「连续流」，它不太适用于依赖对端响应数据的发送，
	即本端后续发送的数据需要由前一个数据的响应来决定的「紧密交互」情形。


概念
====
与UDP相同，本协议中没有连接的概念，端点可以向任意目标端直接发送数据。一对已经穿透NAT并保持通信状态的端点可称为一个「连系」。
就像TCP建立连接的握手，建立一个连系需要打个招呼，它是一次会话申请和一次会话确认。
会话确认初始化验证数据，为接下来的通信提供基本的安全保障。
因为NAT的原因，连系有保活的概念，主动断开可以发送1-2个Bye包（无需确认）。同时，如果不活了也就断开了。

连系
----
	通过某些中介获得对端的地址信息（IP:Port），发送会话申请建立一个连系。
	连系不是连接。连接是一种状态，连系是一种松散的关系约定，更像是一种「存在」。
	它主要用于定义两个端点之间通过穿透而维持的可交互状态。

	如果一方向另一方发起请求（查询），则开启了一个交互期。


交互期
------
	两个端点相互传递数据，彼此尚未全部交付的时间段称为「交互期」。
	当彼此的数据都全部完成后，称为一个交互期结束。
	每个交互期是一个完整的传输逻辑，再次启动传输即为开启一个新的交互期。


轻启动
------
	起始数据报大小取固定最小值，然后依MTU通告/确认进行调整。
	起始的数据发送速率也较慢，之后根据距离回馈评估进行自适应。
	初始数据报大小：576 bytes
	初始发送速率：  5 ms/packet
	注：
	由确认距离和己方的发送速度可评估网络状况。


ACK滞速
-------
	当前发送包与进度线的距离制约发送的速率，距离越大发送越慢。

	接收端可以通过缓发ACK来降低发送方的发送速度：当新的包到达时不再返回ACK确认。
	这与即时返回新包的ACK但进度线保持不变不同，确认距离的加大会让发送方评估为丢包。

	这里有一个例外：
	单包（数据体未分解）的ACK确认会及时返回，以优化交互式通信的效率（如ssh）。


评估重发
--------
	如果发送方收到的回馈包里确认距离加大，也即进度线未移动，说明很可能已经丢包。
	则会触发距离起点的包重发（通过距离和确认号即可计算出来）。
	这是常见的情形。

	如果数据体本来就小，同时缺乏后续其它数据的连续发送而无法体现「距离」，
	此时的丢包就只能由接收端主动的请求重发了。

	重发的距离判断与发送的速率本身有关：速率越高容忍的距离越大（注：速率会被动态修订）。


超时重发
-------
	如果一个数据体的分组很少而又全部丢失，则接收端因无法感知而无法请求重发。
	此时就需要超时重发机制。

	每个数据体都有一个超时计时器。超时后会通知重发数据体的首个分组。
	超时采用2倍指数退避方式，最高延时不超过2分钟（初始1s）。

	对于一个数据体来说，只要接收端收到一个分组，就可以判断丢包了（BEG/END）。
	之后不再依赖超时机制。


重新组包（Repacketization）
--------------------------
	丢包重发时，合并连续的小包重新发送。
	它可以避免后续小包丢失的请求重发或评估重发，减少往返时间浪费。
	这是一个自动的优化措施，通常用于交互式通信里的大量小包传输或路径MTU变大时。

	与TCP相同，这得益于数据报序列号以字节计数的编码方式。
	注：若以数据报个数编号则会有二义性问题。


速率评估
--------
	主要从距离进行评估，参考数据量权衡基准速率。
	距离：
	 - 发送距离越大，是因为对方确认慢，故减速。
	 - 确认距离越大，丢包概率越大，故减速。设置丢包认可。
	数据量：
	 - 数据量越小，基准速率向慢（稳）。降低丢包评估重要性。
	 - 数据量越大，基准速率趋快（急）。丢包评估越准确。
	因子变量：
	 1. 基线。即基准速率的自动调优值。
	 2. 斜率。速率增幅，越接近基线则越慢。
	 3. 跌幅。丢包之后的减速量（快减），拥塞响应。


动态速率
--------
	基准速率乘以一个1.0上下波动的变量q即为动态速率。
	发送距离越大，q值越小，实现降速的目的。反之则为加速。
	q值被按一定节奏地更新，评优、记忆，以实现发送速率的自适应。


缓增骤减
--------
	如果MTU改变，增大时数据报会变大，此时会立即降速。
	降速参考MTU改变前的带宽，然后逐渐提速。通常约3秒充满新的带宽。

	MTU减小时表示带宽缩减，数据报会变小。
	此时速率不变，总的数据量表现为骤减。之后速率自适应。


确认延时
--------
	接收端收到数据后并不是立即返回ACK确认，它有一个基本延时。
	这个延时用于优化ACK的合并，以及收集接收端的应用数据（携带发送）。
	该值应当是用户可设置的。


流式模拟
--------
	如果需要转换为传统TCP的「流式」逻辑，由外部应用主动读取/写入。
	可实现一个缓存子服务。
	服务端：
	- NewReader 返回的Reader从内部缓存读取，始终不会输出io.EOF。
	客户端：
	- Receive 通过缓存转换，提供流式读取接口。

	缓存调优：
	- 应用读取速率评估；
	- 在传数据量（容量基线，RTT相关）；


会话校验
--------
	攻击者可能伪造大量不同源IP向同一服务端提交请求，试图激发大量客户端向同一服务器产生反应。
	采用会话校验码避免：
	- 请求方在初始的会话申请中，创建一个随机的16字节token存放于负载前段。
	- 服务端回应一个8字节的会话码code和8字节的校验和：CRC64(token+code)。
	- 请求方根据该信息验证服务端的准确性。
	- 最终的会话校验码为：CRC64(code+token)。
	即：
	如果想要窃取会话校验码，攻击者必须同时截获初始连系的往返两个数据报。


流程
====
	客户端：
	应用请求 >> [发送]；[接收] >> 写给应用。

	服务端：
	[接收] >> 询问应用获取io.Reader，读取 >> [发送]。

	注：
	1. 发送指发送数据到网络，接收指从网络接收数据。
	2. 回调模式无需缓存（故无窗口）。


参数
====
	lineCaps: n			容量基线（数据报个数）。在传数据容量，类似带宽时延积
	baseRate: 5ms		基础速率。初始默认发包间隔
	minRate: 100μs 		极限速率。万次/秒
	rateUpdate: 500ms 	速率更新间隔
	aliveTime: 120s		保活时间界限
	aliveIntvl: 10s		保活报文间隔时间
	aliveProbes: 6		保活探测次数上限


参考
====

发送的结束
----------
	当发送方发送了最后一个数据报后（END），会启动一个计时器。
	如果一直未收到END包的确认，则超时后发送服务自动结束。

	发送方不会主动重发END包（和其它任何包），
	如果END包丢失，接收端会主动请求重发，而不是由发送方「超时重发」。

	发送方一直未收到END包的确认只会是因为END包的确认丢失所致。
	而且发送方会在收到END确认后发送一个BYE包，如果接收端没有收到BYE信息，
	会主动再次确认END包，通常最多3次（可配置）。

	在超时时段内，接收端的重发申请会足够多（可达数十次），
	因此发送方的超时退出可认为是安全的。

	评价：
	重发申请与其它确认信息一样，是可携带对方需要的数据一起发送的，
	同时这样的大量重发申请只是一种理论容度，通常很难发生。
	并且发送的速率也为正常的实时评估。所以其并不会对网络拥塞造成负面强化。


接收端RTT估算
-------------
	发送方收到新的进度线ACK后，会立即发送新的数据（如果有），
	因此接收端可据此估算RTT值。
	注：
	发送方没有对RTT值的需求。发送速率由接收端制约（间接控制）。


接收端对发送速率的估算
----------------------
	发送方初始为基于基准速率的匀速发送，直到收到第一个ACK确认。
	初始发送的数据报的发送距离为一个特殊值 0xff（表示无效）。
	当收到首个ACK确认后，记录一个「容量基线」值，即为数据在网络上的在线容量。
	此时的发送距离记为0。
	之后的发送包的发送距离在此系统基础上计算。

	源于此规则，接收端可以从收到的首个报文和首个0距离的报文估算平均的发送速率：
	（报文数量/时段长）。

	注：
	- 值0xff在距离中不用，它表示距离无效（缺乏参考点）。
	- 容量基线是由收到的首个ACK计算而来的，因为它可能并不是首个发送包的确认。


长时间间隔之后的再次传输
------------------------
	两个端点间较长时间未传输数据后，网络状态变化，情况未知。
	此时新的基准速率取值：
		（前阶最佳基准线 + 系统默认基准线）/ 2
	数据报大小取前阶值。



接口设计
========
1.
缺失的分组可能可以忽略（如视频），因此支持跳过缺失的确认。
函数：
	// 忽略当前缺失的分组，跳至最接近的后段分组。
	// 返回跳过的分组数。
	func Ignore() int

	// 返回进度线与最近后段分组的距离。
	func Space() int


2.
在一个连系上支持并行发送，可以降低对系统的要求。如端口数，新连系的NAT穿透与保活等。
但数据体的独立处理方式让小数据体（几个分组）难以通过距离评估。

为缓解这一问题，客户端可以自定义数据体的逻辑，即可以将多个小数据体的逻辑合并为一个。
这通过请求查询时提供相同的数据名称来实现。
函数：
	// 名称绑定到数据ID，名称不变则数据ID不变。
	func Query(name string, res []byte, rec Receiver)



注记
===============================================================================
每个数据体在自己的一个Go程内管理发送逻辑，发送距离有255的最长限制。
而把数据报实际写入网络是由一个发送总管负责，以保持有规律的发送间隔（速率）。
发送总管从一个信道中获取待发送的数据，没有长度限制。其速率由各数据体Go程协调控制。




数据流图
===============================================================================
                     |                                  |
       (B Peer)      |                                  |       (A Peer)
                     |                                  |
                     |                                  |
   +---> servSend    |                                  |    recvServ ----+
   |         |       |                                  |       A         |
   |         |       |                                  |       |         | AckReq
   |         |       |                                  |       |         | (Rcv, Dist, RTP)
   |         V       |                                  |       |         |
   +--- +---------+  |                                  |  +---------+ <--+
        | service |  | <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< |  | xSender | <~~~~~~ Request
~~~~~~> | xSender |  | >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> |  | service |
   +--> +---------+  |                                  |  +---------+ ---+
   |         |       |                                  |       A         |
   |         |       |                                  |       |         | Rcv, Dist
   |         |       |                                  |       |         | (速率控制)
   |         V       |                                  |       |         |
   +---- recvServ    |                                  |    servSend <---+
                     |                                  |
                     |                                  |


1. Request(A):
	应用客户发起资源请求。

2. xSender(A):
	分配数据体ID。
	- 创建请求发送子服务（servSend）。
	- 创建对应响应数据体的接收子服务（recvServ）。

	发送请求数据报可携带对端其它响应数据的确认（Ack）。

3. service(B):
	接收网络数据报，解析分配工作任务。
	为资源请求时：
	- 创建请求数据报接收子服务（recvServ）。
	- 接收完毕后，创建数据体发送子服务（servSend），提交请求。

	为对端的响应数据（B曾向A发送过资源请求）时：
	- 交由接收子服务处理，接口：Post(...)。注：recvServ已创建
	- 接收到BYE通知，停止接收子服务，清理缓存池。

--- 以下为并行逻辑

4. servSend(B):
	- 响应从注册的服务应用读取响应数据。
	- 请求从传递的检索标识序列中读取数据。

	根据对端反馈的确认距离（Dist）评估发送速率（休眠时长）。
	向 xSender 递送构造好的数据报。

5. recvServ(B):
	- 接收对端的请求数据，完成后提交到响应发送子服务。
	- 接收对端的响应数据，写入请求时提供的应用接收器（Receiver）。
	  根据应用接收器对数据的消耗速度自行决定确认进度，约束对端的发送速率。

--- 以下回归发送总管（xSender）

6. xSender(B):
	- 获取各数据体需要发送的请求或响应数据报；
	- 获取各接收器的确认申请或重发请求申请；

	组合待发送数据报和确认（重发请求）申请，发送数据报。

7. service(A):
	接收B端发来的网络数据，...参考如上第3点。


局部细节（A Peer）
-------------------------------------------------------------------------------
             |                                                     |
             |               [Client's Receiver]                   |
             |                     A                               |
             |                     |                               |
             |               +----------+                          |
             |        +----> | recvServ | -----+                   |
             |        |      +----------+      |                   |
             |        |                        | AckReq            |
             |        | (Data)                 | (Rcv, Dist, RTP)  |
             |        |                        |                   |
             |        |          A request     |                   |
             |        |          ---------+    |                   |
             |        |                    \   V                   |
(B Peer)     |  +-----------+            +-----------+             |
>>>>>>>>>>>>>>> |  service  |            |  xSender  | >>>>>>>>>>>>>>>>>>> (B Peer)
(Request)    |  +-----------+            +-----------+             |
(or Data)    |        |                        A                   |
             |        |                        |                   |
             |        | Rcv, Dist, RTP         | (Packets)         |
             |        |                        |                   |
             |        |      +----------+      |                   |
             |        +----> | servSend | -----+                   |
             |               +----------+                          |
             |                     A                               |
             |                     |                               |
             |                     +---- [Server's Responser]      |
             |                                                     |
             |                                                     |


注：
Request 客户端请求
Data 服务端响应数据
Client's Receiver 客户端接收器，接收 Data
Server's Responser 服务端响应器，响应 Request
