四元链哈希树
------------

父节点哈希值 = Hash（子节点哈希 + 后3个兄弟节点哈希）
模拟默克尔树，顶端2-4个节点合并即生成树根。

每一层中间节点需前置一个所在层级值，加上合并计算的哈希值。21字节长。
对于外部，树根哈希也应前置层级值。

图示（L4）
	H30 ......
	 A
	 V
	H20 <================================================================> H21 ......
	 A									A
	 V									V
	H10 <===================> H11 <====================> H12 <==== ... --> H14 ...... => H1[n/4]
	 A		     	   A		      	      A
	 V		     	   V		      	      V
	T0 <=> T1 <=> T2 <=> T3 -> T4 <=> T5 <=> T6 <=> T7 -> T8 <=> T9 <=> T10 ......... => T[n]

算法：
	H10 = 1 + sha1( sha512(T0 + T1 + T2 + T3) )
	H20 = 1 + sha1( sha512(H10 + H11 + H12 + H13) )
	Hx0 ......
	注：
	- 首1字节为链所在当前层级，从1开始，从下往上，最多256层。
	- 合并计算的节点之间为双向链，最末一个指向下一段时为单向。

特性：
	- 拥有传统默克尔树的哈希校验功能（任一子节点变化都会扩展至根）。
	- 可以简单的获取某一个层级的成员，两个端点可以批量核对整棵树（逐层或跨层）。
	- 相比于二叉树有更少的层级，中间结点数量缩减至叶节点的33%（二叉树为100%），而效率相当。

实现：
	- 包含3个指针：Prev, Down, Next。支持上下和水平两个方向的快速检索。
	- 子段起始节点的Prev指向上一层节点（如T0），否则指向其前一个节点（双向链段）。
	- 包含1字节的层级计数，用于判断Prev节点是否同层。
	- 为快速检索位置有序插入新节点，中间结点保存其底端叶子节点值的一个副本。
	  注：可能只需时间戳即可。

参考：
	假设叶节点为交易ID，65536笔交易；ID长度28字节；中间结点21字节（1+20）。
	树大小：
		65536 * 28 = 1,835,008
		21844 * 21 = 458,724
		合计：2,293,732 ~= 2.2MB
	对比：
	Bitcoin现有默克尔树，交易ID与中间节点长32字节。
	树大小：
		65536*2 * 32 = 4,194,304 = 4MB

	注：
	交易ID 28字节算法（8+20）：时间戳 + sha1( 时间戳 + sha512(交易数据) )。
	多一层sha512计算，安全性保证且更高。


